//Author: Wang Jiadong
//Matric Number: A0105703
//Email: E0267418@u.nus.edu

#include <cstdio>
#include <iostream>
#include <set>
#include <map>
#include <stack>

#include "llvm/IR/LLVMContext.h"
#include "llvm/IR/Module.h"
#include "llvm/IR/Function.h"
#include "llvm/IR/Instructions.h"
#include "llvm/IR/Instruction.h"
#include "llvm/IRReader/IRReader.h"
#include "llvm/Support/SourceMgr.h"
#include "llvm/Support/raw_ostream.h"

#define ANSI_COLOR_RED     "\x1b[31m"
#define ANSI_COLOR_GREEN   "\x1b[32m"
#define ANSI_COLOR_YELLOW  "\x1b[33m"
#define ANSI_COLOR_BLUE    "\x1b[34m"
#define ANSI_COLOR_MAGENTA "\x1b[35m"
#define ANSI_COLOR_CYAN    "\x1b[36m"
#define ANSI_COLOR_RESET   "\x1b[0m"

using namespace llvm;

std::set<Instruction*> detectTaint(BasicBlock*,std::set<Instruction*>);
std::set<Instruction*> union_sets(std::set<Instruction*>, std::set<Instruction*>);

int main(int argc, char **argv)
{
    // Read the IR file.
    //IMPORT THE IR FILE
    LLVMContext &Context = getGlobalContext();
    SMDiagnostic Err;

    // Extract Module M from IR (assuming only one Module exists)
    Module *M = ParseIRFile(argv[1], Err, Context);
    if (M == nullptr)
    {
      fprintf(stderr, "error: failed to load LLVM IR file \"%s\"", argv[1]);
      return EXIT_FAILURE;
    }
    //STOP HERE IF THE IMPORTING IS FAILED


    //FIND THE MAIN FUNCTION
    //WHICH IS THE GLOBAL ENTRY
    // 1.Extract Function main from Module M
    Function *F = M->getFunction("main");
    
    // 2.Define analysisMap as a mapping of basic block labels to empty set (of instructions):
    // For example: Assume the input LLVM IR has 4 basic blocks, the map
    // would look like the following:
    // entry -> {}
    // if.then -> {}
    // if.else -> {}
    // if.end -> {}      


    //CONSTRUCT A MAP  
    std::map<BasicBlock*,std::set<Instruction*>> analysisMap;


    //FOR EACH BASIC BLOCK INSIDE THE FUNCTION
    for (auto &BB: *F){
      std::set<Instruction*> emptySet;
      //INITIALIZE THE GLOBAL MAP
      BasicBlock *blockPointer = &BB;
      analysisMap[blockPointer] = emptySet;
      
      // std::out << BB.str().c_str() << std::endl;
      // BB.printAsOperand(err(), false);
    }      
    // Note: All variables are of type "alloca" instructions. Ex.
    // Variable a: %a = alloca i32, align 4

    // 3. Traversing the CFG in Depth First Order
    // In order to do so, we use a stack: traversalStack.
    // First, we add the initial analysisNode consisting of the following two items to the stack:
    //      - entry basic block 
    //      - an empty set (of instructions) as the initial list of initialized variables



    //INITIALIZE THE GLOBAL STACK
    std::stack<std::pair<BasicBlock*,std::set<Instruction*> > > traversalStack;


    //FIND THE INIT(FUNCTION)
    BasicBlock* entryBB = &F->getEntryBlock();

    // INITIALIZE THE ENTRY SET OF THE INITIALIZED VARIABLES
    // WHICH IS EMPTY NOW
    std::set<Instruction*> emptySet;
    //INITALIZE THE PAIR
    //ENTRY BASIC BLOCK & EMPTY SET
    std::pair<BasicBlock*,std::set<Instruction*> > analysisNode = std::make_pair(entryBB,emptySet);
    //PLACE IT INTO THE TRAVERSAL STACK
    traversalStack.push(analysisNode);
    
    // 4. while the stack is not empty we pop the top analysisNode
    // An updated analysis (list of initialized vars) is generated by running the findInitializedVars on the analysisNode
    // The updated list of initialized vars is unioned with the current list of initialized vars for the basic block in the 
    // analysis Map
    // Finally, the successor nodes of the current basic block with the updated list of initialized vars is added to the stack
    // Extract updatedInitializedVars (The list of initialized variables after BB) from BB and initializedVars
    // from it, and then we add all its successors to it    
    while(!traversalStack.empty()){
      // Pop the top analysis node from stack

      //GET THE TOP ELEMENT OF THE TRAVERSAL STACK
      std::pair<BasicBlock*,std::set<Instruction*> > analysisNode = traversalStack.top();

      traversalStack.pop();
      



      // Extract the basic block and the set of initialized variables from  analysisNode
      

      // EXTRACT THE BASIC BLOCK FROM THE PAIR.
      BasicBlock* BB = analysisNode.first;
      


      // EXTRACT THE INITIALIZED INSTRUCTION SET FROM THE PAIR
      std::set<Instruction*> initializedVars = analysisNode.second;     

      // errs()<< "BasicBlock: =============";
      // BB -> printAsOperand(errs(), false);
      // errs() << "\n";


      // Extract updatedInitializedVars (The list of initialized variables 
      // after BB) from BB and initializedVars
      //FIND THE UPDATED INITIALIZED VARIABLES

      // std::pair<std::set<Instruction*>, std::set<Instruction*>> detectResult = ;
      std::set<Instruction*> updatedInitializedVars = detectTaint(BB,initializedVars);
      // std::set<Instruction*> killedInitializedVars = detectResult.second;

      // errs() << "Before Detection\n";
      // for(Instruction* ins : analysisMap[BB]){
      //   ins-> dump();
      // }

      // errs() << "After Detection\n";
      // errs() << "updated:\n";
      // for(Instruction* ins : updatedInitializedVars){
      //   ins-> dump();
      // }
      // errs() << "killed: \n";
      // for(Instruction* ins : killedInitializedVars){
      //   ins-> dump();
      // }

      // Update the analysis of node BB in the MAP to the union of currently sored InitializedVars 
      // and the generated updatedInitializedVars
      std::set<Instruction*> unionInitializedVars = union_sets(analysisMap[BB],updatedInitializedVars); 
      // for(Instruction* ins : killedInitializedVars){
      //   // errs() << "try dumping...";
      //   // ins -> dump();
      //   if(unionInitializedVars.find(ins) != unionInitializedVars.end()){
      //     unionInitializedVars.erase(ins);
      //   }
      //   // errs() << "....Done.\n";
      // }
      // unionInitializedVars.erase(killedInitializedVars.cbegin(), killedInitializedVars.cend());
      analysisMap[BB] = unionInitializedVars;
      // errs() << "AfterAll: \n";
      // for(Instruction* ins : unionInitializedVars){
      //   ins-> dump();
      // }
      // Extract the last instruction in the stack (Terminator Instruction)
      const TerminatorInst *TInst = BB->getTerminator();

      // Extract the number of successors the terminator instructor has
      int NSucc = TInst->getNumSuccessors();
  
      for (int i = 0;  i < NSucc; ++i) {
            // for all successor basic blocks, add them plus the updatedInitializedVars to the stack 
            // if fixpoint condition is not met.
            //
            // Fixpoint Condition:
            // We only add successor nodes to the stack if the union of the new list of initialzied variables for 
            // the successor node is different from the currently stored list of initialzied variables
            // for the successor node.
            
            // Load the current stored analysis for a successor node
            BasicBlock *Succ = TInst->getSuccessor(i);    
            std::set<Instruction*> succInitializedVars = analysisMap[Succ];
          if (succInitializedVars != unionInitializedVars){
              std::pair<BasicBlock*,std::set<Instruction*> > succAnalysisNode = std::make_pair(Succ,updatedInitializedVars);
             traversalStack.push(succAnalysisNode);
            }

      } 
    }
    
    // When we exit the loop the analysis have finished and the analysis map will point to the set of 
    // initialized instructions at each basic block. Ex.
    // entry -> {%a = alloca i32, align 4}
    // if.then -> {%a = alloca i32, align 4}
    // if.else -> {}
    // if.end -> {%a = alloca i32, align 4, %b = alloca i32, align 4}  
    //
    // We now print the analysis results:
    errs() << "With Registers: \n";
    int flag = false;
    for (auto& row : analysisMap){
      std::set<Instruction*> initializedVars = row.second;
      //std::string BBLabel = row.first;
      //errs() << BBLabel << ":\n";
      row.first->printAsOperand(errs(), false);
      for (Instruction* var : initializedVars){
        errs() << "\t";
        var->dump();

        const TerminatorInst *TInst = row.first->getTerminator();
        int NSucc = TInst->getNumSuccessors();

        if (NSucc == 0) {
          if (strncmp(var->getName().str().c_str(),"sink",4) == 0) {
            flag = true;
          }
        }
      }
      errs() << "\n";
    } 


    errs() << "Without Registers: \n";
    for (auto& row : analysisMap){
        std::set<Instruction*> taints = row.second;
        BasicBlock *BB = row.first;
        BB->printAsOperand(errs(), false);
        errs() << ":\t {";
        for (Instruction* taintInstruction : taints){
           std::string temp = taintInstruction -> getName().str().c_str();
           if(temp.size() == 0){
             continue;
           }
           if(taintInstruction != *taints.begin()){
            errs() << ",";
           }
           errs() << " ";

           errs() << temp;

           // var->dump();
        }
        errs() << "}\n";
    }




   
    return 0;
}
// Performs set union
std::set<Instruction*> union_sets(std::set<Instruction*>A, std::set<Instruction*> B)
{
     A.insert(B.cbegin(), B.cend());
     return A;
}

std::set<Instruction*> detectTaint(BasicBlock* BB, std::set<Instruction*> secretVars){
  //copy the secret vars array
  //but I dont understand, why have to copy?
  std::set<Instruction*> newSecretVars(secretVars);
  std::set<Instruction*> kilSecretVars;
  
  
  // Loop through instructions in BB
  //I instructions, pass by reference
  for (auto &I: *BB)
  {

    //TESTING
    //I.getName:
    //If it is initialize new value, then it is the name of that variable
    //com: for logic comparison
    //call: for function call.
    // std::cout << "<<<<" << std::endl;
    // printf(ANSI_COLOR_RED "%s"  ANSI_COLOR_RESET "\n", I.getName().str().c_str());
    // printf(ANSI_COLOR_RED "%s"  ANSI_COLOR_RESET "\n", );
    // std::cout << ">>>>" << std::endl;


    //INITIALIZATION
    // Add secret variable to newSecretVars
    // when secret is initialized  
    if (strncmp(I.getName().str().c_str(),"source",6) == 0){
      // Print 
      //initialization
      // printf(ANSI_COLOR_BLUE "Source found:%s" ANSI_COLOR_RESET "\n", I.getName().str().c_str());
      newSecretVars.insert(dyn_cast<Instruction>(&I));
    }else if (isa<StoreInst>(I)){
      // Check store instructions
      // e.g. store i32 0, i32* %retval
      //operand 0: the value that is going to be assigned
      //operand 1: the variable
      Value* v = I.getOperand(0);
      Instruction* op1 = dyn_cast<Instruction>(v); 

      v = I.getOperand(1);
      Instruction* op2 = dyn_cast<Instruction>(v);

      // errs() << "Store:"
      // I.dump();
      // errs() <<  
      // If the FV is part of the secrets, insert the assigned variable
      //if the value expression is not NULL
      //if we can find it inside the secrets
      //then, put the variable into the secret set.
      if (op1 != nullptr && newSecretVars.find(op1) != newSecretVars.end()){
         newSecretVars.insert(op2); 
         // kilSecretVars.erase(op2);
      }else if(op1 != nullptr || (newSecretVars.find(op1) == newSecretVars.end() && newSecretVars.find(op2) != newSecretVars.end())){
         newSecretVars.erase(op2);
         // kilSecretVars.insert(op2);
      }else{
        ;
      }
    }else{  
      // Check all other instructions
      bool flag = false;
      for (auto op = I.op_begin(); op != I.op_end(); op++) {
        

        //parse the oprand as an instrcution type.
        Value* v = op->get();
        Instruction* inst = dyn_cast<Instruction>(v);
        

        // for each assignment, if the FV contains secret, then the assigned also.
        if (inst != nullptr && newSecretVars.find(inst) != newSecretVars.end()){
          newSecretVars.insert(dyn_cast<Instruction>(&I));
          // if(kilSecretVars.find(&I) != kilSecretVars.end())
          //   kilSecretVars.erase(dyn_cast<Instruction>(&I));
          flag = true;
        }
      }
      if(!flag){
        // errs()<<"To Remove: ";
        // I.dump();
        // errs() << "\n";
        kilSecretVars.insert(dyn_cast<Instruction>(&I));
        // if(newSecretVars.find(&I) != newSecretVars.end())
        //   newSecretVars.erase(dyn_cast<Instruction>(&I));
      }
    }
  }
  return newSecretVars;
}

